from typing import List, Optional, Union

import requests
import streamlit as st

from toolbox.Structures import Image

from . import BaseTemplate


class SimplePredict(BaseTemplate):

    def __init__(self, **kwargs):
        """Create the SimplePredict Project template.
        """
        super().__init__(**kwargs)

        # Streamlit widgets
        self._st_input_image = None
        self._st_input_image_id = None
        self._st_preview_image_id = None
        self._st_output_image = None
        self._st_output_json = None
        self._st_button_predict = None

        self._uploaded_file = None

    def _call_api_predict(self, image_id: str,
                          post_to_broker: Optional[bool] = None
                          ) -> List[dict]:
        """Call the predict method of the API.

        Args:
            image_id (str): ID of the image to predict.
            post_to_broker (Optional[bool], optional): Post the generated
                entity to the context broker. None to use the API defaults.
                Defaults to None.

        Raises:
            HTTPError: If the request fails.
                
        Returns:
            List[dict]: A list of entities generated by the API.
        """
        route = self.get_api_path("predict")
        content = {"entity_id": image_id, "post_to_broker": post_to_broker}
        self.logger.info(f"Calling {route} with {content}")
        response = requests.post(route, json=content)
        if not response.ok:
            self.logger.error(
                f"Got {response.status_code} from {route} ({response.text})"
            )
            response.raise_for_status()
        self.logger.info(
            f"Got {response.status_code} from {route}"
        )
        return response.json()

    def _predict_image(self, image_id: str):
        """Call the API to predict the given image id and update the UI.

        Args:
            image_id (str): Input image id.
        """
        try:
            entities = self._call_api_predict(image_id)
        except Exception as e:
            self._st_output_json.error(f"Error: {str(e)}")
        else:
            self._st_output_json.json(entities)
            self._visualize_entities(entities)

    def _set_input_image(self, image_id: str) -> bool:
        """Set the input image and update the UI.

        Args:
            image_id (str): ID of the image on the image storage.

        Returns:
            bool: True if the image was found on the image storage, else False.
        """
        try:
            parsed_id = image_id.replace(":", "\:")
            image = self.image_storage_cli.download(image_id)
            self._st_input_image.image(image.image, channels="BGR")
            self._st_preview_image_id.caption(f"ID: {parsed_id}")
            return True
        except:
            self._st_input_image.error(
                f"Error: Image '{parsed_id}' not found on "
                f"{self.image_storage_cli.url}"
            )
            return False

    def _upload_image(self, st_uploaded_file) -> str:
        """Uploads an image previously uploaded to the Streamlit app to the
        image storage and updates the UI.

        Args:
            st_uploaded_file (streamlit.uploaded_file_manager.UploadedFile): 
                Image uploaded to the Streamlit app.

        Returns:
            str: ID of the image on the image storage.
        """
        try:
            image_id = self.image_storage_cli.upload_bytes(
                image_bytes=st_uploaded_file.read(),
                name=st_uploaded_file.name,
                file_type=st_uploaded_file.type,
                source="toolbox.FrontEnd."+self.name,
            )
        except Exception as e:
            self._st_input_image.error(f"Error: {str(e)}")
        else:
            self._set_input_image(image_id)
            return image_id

    def _visualize_entities(self, entities: List[dict]):
        """Visualize a list of entities by its id. Call the image storage API
        to generate the image, then download it and update the UI.

        Args:
            entities (List[dict]): List of entity dicts to visualize.
        """
        try:
            entity_ids = [e["id"] for e in entities]
            id_vis = self.image_storage_cli.visualize(entity_ids)
            img_vis = self.image_storage_cli.download(id_vis)
            self._st_output_image.image(img_vis.image, channels="BGR")
        except Exception as e:
            self._st_output_image.error(f"Error: {str(e)}")

    def _ui(self):
        """Set the UI widgets.
        """
        st.title(self.name)
        col_input, col_output = st.columns(2, gap="large")

        with col_input:
            st.subheader("Input")
            self._st_input_image_id = st.empty()
            st.write(
                "<p style='color: gray; text-align: center;'>- or -</p>",
                unsafe_allow_html=True
            )
            self._uploaded_file = st.file_uploader(
                "Upload an image",
                type=["png", "jpg", "jpeg", "bmp", "tiff"],
            )
            st.write("</br>", unsafe_allow_html=True)
            self._st_button_predict = st.empty()
            st.divider()
            self._st_input_image = st.empty()
            self._st_preview_image_id = st.empty()

        with col_output:
            st.subheader("Output")
            self._st_output_json = st.empty()
            st.divider()
            self._st_output_image = st.empty()

    def _update(self):
        """Handle the UI logic.
        """
        button_predict_enabled = False
        image_id_to_send = None

        # Set and get the input_image_id widget
        if self._uploaded_file is None:
            image_id_input_enabled = True
        else:
            image_id_input_enabled = False
        input_image_id = self._st_input_image_id.text_input(
            "Image ID",
            disabled=not image_id_input_enabled
        )

        # Download the image by its ID if no image has been uploaded
        if self._uploaded_file is None:
            if input_image_id and self._set_input_image(input_image_id):
                button_predict_enabled = True
                image_id_to_send = input_image_id

        #     input_image_id = self._upload_image(self._uploaded_file)
        # else:
        #     button_predict_enabled = False

        # Predict button
        if self._st_button_predict.button(
            "Predict",
            disabled=not button_predict_enabled
        ):
            self._predict_image(image_id_to_send)

    def __call__(self):
        self._ui()
        self._update()
